// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Custom storage adapter that handles network errors gracefully
const customStorage = {
  getItem: (key: string) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      return null;
    }
  },
  setItem: (key: string, value: string) => {
    try {
      localStorage.setItem(key, value);
    } catch (e) {
      // Ignore storage errors
    }
  },
  removeItem: (key: string) => {
    try {
      localStorage.removeItem(key);
    } catch (e) {
      // Ignore storage errors
    }
  },
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: customStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: false,
    // Disable auto-refresh se non c'√® connessione
    flowType: 'pkce',
  },
  global: {
    fetch: async (url, options = {}) => {
      // LOG CRITICO: Se questo non appare, Supabase non sta usando global.fetch!
      const urlString = typeof url === 'string' ? url : String(url);
      console.log('[Supabase Global Fetch] üö®üö®üö® CALLED! URL:', urlString.substring(0, 150));
      
      try {
        // Check if online before making request
        if (!navigator.onLine) {
          console.error('[Supabase Global Fetch] ‚ùå Network offline');
          throw new Error('Network offline');
        }
        
        // Timeout aumentato per operazioni pi√π lunghe
        // Le chiamate auth potrebbero essere lente, quindi timeout pi√π lungo
        // urlString gi√† definito sopra
        const isAuthCall = urlString.includes('/auth/v1/') || 
                          urlString.includes('/auth/v1/user') ||
                          urlString.includes('token') ||
                          (options?.method === 'POST' && urlString.includes('/auth/'));
        const timeout = isAuthCall ? 30000 : 20000; // 30s per auth, 20s per altre operazioni
        
        // Log dettagliato per vedere tutte le chiamate
        const isInsertCall = urlString.includes('/rest/v1/expenses') && options?.method === 'POST';
        if (isInsertCall) {
          console.log('[Supabase] üîÑ INSERT CALL detected!');
          console.log('[Supabase] URL:', urlString);
          console.log('[Supabase] Method:', options?.method);
          console.log('[Supabase] Headers:', options?.headers);
          console.log('[Supabase] Body preview:', typeof options?.body === 'string' ? options.body.substring(0, 200) : options?.body);
        }
        console.log('[Supabase] Fetch call - URL:', urlString.substring(0, 150), 'Method:', options?.method || 'GET', 'isAuth:', isAuthCall, 'timeout:', timeout);
        
        const controller = new AbortController();
        const fetchStartTime = Date.now();
        const timeoutId = setTimeout(() => {
          const elapsed = Date.now() - fetchStartTime;
          console.error(`[Supabase] ‚è±Ô∏è Request timeout after ${elapsed}ms (limit: ${timeout}ms) - URL:`, urlString.substring(0, 150));
          controller.abort();
        }, timeout);
        
        try {
          if (isInsertCall) {
            console.log('[Supabase] üì° Starting fetch request for INSERT...');
            console.log('[Supabase] üì° Full URL:', urlString);
            console.log('[Supabase] üì° Request options:', {
              method: options?.method,
              headers: options?.headers,
              body: typeof options?.body === 'string' ? options.body.substring(0, 300) : 'Not a string'
            });
          }
          
          // Usa fetch nativo - il Service Worker lo intercetter√† se necessario
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          
          const fetchDuration = Date.now() - fetchStartTime;
          if (isInsertCall) {
            console.log(`[Supabase] ‚úÖ Fetch completed in ${fetchDuration}ms - Status:`, response.status, response.statusText);
            console.log('[Supabase] Response ok:', response.ok);
            console.log('[Supabase] Response type:', response.type);
            console.log('[Supabase] Response headers:', Object.fromEntries(response.headers.entries()));
          }
          clearTimeout(timeoutId);
          return response;
        } catch (error: any) {
          clearTimeout(timeoutId);
          const fetchDuration = Date.now() - fetchStartTime;
          if (isInsertCall) {
            console.error(`[Supabase] ‚ùå Fetch failed after ${fetchDuration}ms for INSERT`);
            console.error('[Supabase] Error name:', error?.name);
            console.error('[Supabase] Error message:', error?.message);
            console.error('[Supabase] Error type:', typeof error);
          }
          // Gestisci errori di rete silenziosamente
          if (error.name === 'AbortError' || 
              error.message?.includes('Failed to fetch') ||
              error.message?.includes('ERR_NAME_NOT_RESOLVED')) {
            // NON ritornare mock response per nessuna chiamata - lascia che gli errori vengano gestiti
            // Return mock solo in casi estremi e solo per chiamate non critiche
            console.error('[Supabase] Network error detected:', error.message, 'URL:', urlString.substring(0, 100));
            throw error;
          }
          throw error;
        }
      } catch (error: any) {
        // Log errori di rete ma rilanciamoli - non nasconderli
        console.error('[Supabase] Fetch error:', error?.message || error);
        throw error;
      }
    },
  },
});